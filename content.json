{"meta":{"title":"Sany's Blog","subtitle":"Getting Better Each Day!!!","description":"技术，故事，还有生活","author":"Sany","url":"http://san-y.github.io"},"pages":[{"title":"","date":"2018-10-08T08:33:49.446Z","updated":"2018-10-08T08:33:49.434Z","comments":true,"path":"404.html","permalink":"http://san-y.github.io/404.html","excerpt":"","text":""}],"posts":[{"title":"Linux 磁盘文件清理","slug":"Linux 磁盘文件清理","date":"2018-10-09T09:11:04.000Z","updated":"2018-10-10T03:50:32.719Z","comments":true,"path":"Linux 磁盘文件清理/","link":"","permalink":"http://san-y.github.io/Linux 磁盘文件清理/","excerpt":"","text":"由于linux 的根目录挂在的大小只有50G，CDH的环境又安装在/opt目录下，导致/目录的可用空间总是岌岌可危。经常面临需要清理硬盘的情况。期间产生了一下问题，故作此记录！ 确认磁盘可用空间 查看磁盘信息： /]# df -lh```12345 可以查看各文件系统（磁盘）下的挂载点的容量使用情况。2. 查看各文件夹大小及定位大文件 &gt; 进入根目录 ```[root@master /]# cd / 查看当前目录各文件夹占用空间大小 /]# du -h --max-depth123456--max-depth=N选项:显示当前目录总计（于--all一起使用时计算文件数），当N为指定数值时计算深度为N，此处我们使用的是1，所以只计算当前目录文件夹。执行如上两个命令后将可以看到/目录下各文件夹占用空间大小，如法炮制，将很快能定位到可以清理的文件目录。&gt; 查看当前目录最大文件并从大到小展现：```[root@master /]# ls -lhS 删除可清理的文件，如日志等注：在生产环境种如果需要删除日志，最好先提前确认日志是否需要需要下载下来供开发人员分析。 删除文件可清理的无用文件: /]# rm -rf 111.log```12345在某些情况下，删除文件后再使用`df -lh`查看磁盘空间，发现磁盘空间并没有变化。是因为在在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。也就是说，虽然日志文件虽然被手动删除，但是并未被释放，进程还是在后台读取着该文件。这时如需彻底删除此文件则需找到对应的使用它的执行进程。&gt; 确认删除文件是否被进程占用(被删除的文件将会被标注为deleted)```[root@master /]# lsof | grep deleted 找到对应的被删除文件的占用线程并kill掉[root@master /]# kill -9 *** 再次查看磁盘空间，磁盘空间被成功释放。注意：kill 掉的进程（应用）也会被一起终止，如果应用需要继续执行，将需要被重启。 最简单的不用重启应用请用日志文件的方式 用覆盖当前日志文件的方式 `[root@master /]# &gt; file.log` `[root@master /]# echo &apos;&apos; &gt; file.log` `[root@master /]# cat /dev/null &gt; file.log`","categories":[{"name":"技术","slug":"技术","permalink":"http://san-y.github.io/categories/技术/"},{"name":"LINUX","slug":"技术/LINUX","permalink":"http://san-y.github.io/categories/技术/LINUX/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://san-y.github.io/tags/linux/"}]},{"title":"异常【JAVA学习笔记】","slug":"异常【JAVA学习笔记】","date":"2018-10-09T09:11:04.000Z","updated":"2018-10-10T03:50:32.738Z","comments":true,"path":"异常【JAVA学习笔记】/","link":"","permalink":"http://san-y.github.io/异常【JAVA学习笔记】/","excerpt":"","text":"一、概述在JAVA中用类的形式对不正常情况进行了描述和封装对象。描述不正常的类，称为异常类。以前正常流程代码和问题代码处理相结合，现在将正常流程代码和问题处理代码分离，提高阅读性。其实异常就是java通过面向对象的思想将代码遇到的问题封装成了对象，用异常类对其进行描述。 Java 中的异常都是基于 C++ 基础之上的。并非所有异常都定义在 java.lang 包中的。 二、异常体系问题很多，意味着描述的类也很多将其共性进行向上抽取，形成了异常体系： 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 Throwable Throwable是 Java 语言中所有错误或异常的超类。 Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。 Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。 在 Throwable 中只有三个基本的异常类提供了带 cause 参数的构造器，分别是 Exception、Error、RuntimeException，如果要链接其他类型的异常类，应该使用 initCause() 方法。 Error(它们在应用程序的控制和处理能力之外) 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 它用于表示编译时和系统错误（除非特殊情况，一般不用关心？）——《Java 编程思想》 和RuntimeException一样，编译器也不会检查Error。 Exception(是所有基本异常的基类) Exception 是程序正常运行中，可以预料的意外情况，可以预料的意外情况，可能并且应该被捕获，进行相应处理。 Exception又分为可检查（checked)异常和不可检查（unchecked)异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译器检查的一部分。 自定义异常是 checked Exception。 RuntimeException（不检查（unchecked)异常） 是 Exception 子类，但属于 unchecked excepiton。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误，即那些可能在 Java 虚拟机正常运行期间抛出的异常。编译器不会检查RuntimeException异常。通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。 eg: 若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！ 如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！ Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，不可查异常(unchecked Exception)。其中不可查异常又分为运行时异常(RuntimeException 及其子类)和错误(Error). 三、异常的处理try-catch用来处理异常，throws用来抛出异常。 Throws抛出原理如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键词操作，throws ,throw。 throws和throw的区别： throws用在函数上（在函数上用throws对该类进行声明，以便于调用者对该问题预先的定义处理方式，throw用在函数内。 throws抛出的是异常类，可以抛出多个，用逗号隔开。throw抛出的是异常对象。 Try-Catch捕获形式这是可以对异常进行针对性处理的方式。 try{//需要被检测异常的代码} catch(异常类 变量){//处理异常的代码} 一个捕捉当中存在几个catch情况:如果存在父类catch情况，一定要把父类catch放在catch语句的最后面。 finally{//一定会被执行的代码}通常用于关闭（释放）资源。finally只要存在就会被执行，只有一种情况不会被执行，System.exit(0)关闭JVM。 1234567891011121314151617 try &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;请输入除数：&quot;); int num1 = input.nextInt(); System.out.println(&quot;请输入被除数：&quot;); int num2 = input.nextInt(); int num = num1/num2; System.out.println(&quot;商是：&quot;+num); System.exit(1);//强制退出JVM进程 &#125; catch (Exception e) &#123;//Exception捕获异常的实例对象// e.printStackTrace(); 输出所有异常信息/* String mes = e.getMessage();//返回异常的错误信息,这种方法不常用 System.err.println(mes);*/ &#125; finally &#123;//finally块中代码始终会被执行 System.out.println(&quot;感谢使用&quot;); &#125; try catch finally代码块儿组合特点: try catch finally try catch（多个）: catch和finally块为可选，但两者至少出现其中之一。当没有必要资源需要释放时，可以不用定义finally。 try finally ：异常无法直接catch处理，但是资源需要关闭。 发生异常的执行顺序： 执行try、catch块中return之前的语句 执行finally块中的语句 执行try、catch块中的return语句 扩展：随着 Java语言的发展，引入了一些更加便利的特性，比如try-with-resources 和 multiple catch，具体可以参考下面的代码段。在编译时期，会自动生成相应的处理逻辑，比如按照约定熟成close那些扩展了AutoCloseable或者Closeable的对象。 123456 try (BufferedReader br = new BufferedReader(…); BufferedWriter writer = new BufferedWriter(…)) &#123;// Try-with-resources// do somethingcatch ( IOException | XEception e) &#123;// Multiple catch // Handle it&#125; 四、异常处理的原则 尽量不要使用类似Excption这样的通用异常，而是应该捕获特定异常。(方便查询问题，让代码直观的体现出尽量多的信息） 不要生吞（swallow）异常。如果我们不把异常抛出，或者也没有输出到日志（Logger)之类，程序可能在后续代码以不可控的方式结束，就很难判断哪里抛出了异常，及什么原因产生了异常。 尽量不要使用e.printStackTrace()的方式输出错误日志，看看printStackTrace()的文档，该方法的错误日志信息会以standard error stream的方式输出。问题就在这里，在稍微复杂一点的生产系统中，标准出错(STERR）不是个合适的输出选项，因为你很难判断日志到底输出到哪里去了。特别在分布式系统中，如果发生异常，但是无法找到堆栈轨迹（stacktrace),这纯属为诊断设置障碍。所以，最好使用产品日志，详细地输出到日志系统里。 Throw early,catch late原则： 不要推诿或延迟处理异常，就地解决最好，并且需要实实在在的进行处理，而不是只捕捉，不动作。 Throw early 尽早抛出异常：eg:void readPreferences(String fileName)&#123;1234 //...perform operations... InputStream in = new FileInputStream(fileName); //...read the preferences file...&#125; 如果 fileName 是 null，那么程序就会抛出 NullPointerException，但是由于没有第一时间暴露出问题，堆栈信息可能非常令人费解，往往需要相对复杂的定位。这个 NPE 只是作为例子，实际产品代码中，可能是各种情况，比如获取配置失败之类的。在发现问题的时候，第一时间抛出，能够更加清晰地反映问题。我们可以修改一下，让问题“throw early”，对应的异常信息就非常直观了。 void readPreferences(String filename) &#123;12345 Objects. requireNonNull(filename); //...perform other operations... InputStream in = new FileInputStream(filename); //...read the preferences file...&#125; catch late 至于“catch late”，其实是我们经常苦恼的问题，捕获异常后，需要怎么处理呢？最差的处理方式，就是我前面提到的“生吞异常”，本质上其实是掩盖问题。如果实在不知道如何处理，可以选择保留原有异常的cause 信息，直接再抛出或者构建新的异常抛出去。在更高层面，因为有了清晰的（业务）逻辑，往往会更清楚合适的处理方式是什么。 有的时候，我们会根据需要自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑： 是否需要定义成 Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。 在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看 Java 的标准类库，你可能注意到类似 java.net.ConnectException，出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数据一般是不可以输出到日志里面的。 五、异常性能开销我们从性能角度来审视一下 Java 的异常处理机制，这里有两个可能会相对昂贵的地方： try-catch 代码段会产生额外的性能开销，或者换个角度说，它往往会影响 JVM 对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的 try 包住整段的代码；与此同时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。 Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。 当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。关于诊断后台变慢的问题，我会在后面的 Java 性能基础模块中系统探讨。 六、常见面试问题 NoClassDefFoundError 和 ClassNotFoundException 有什么区别？NoClassDefFoundError是一个错误(Error)，而ClassNOtFoundException是一个异常，在Java中对于错误和异常的处理是不同的，我们可以从异常中恢复程序但却不应该尝试从错误中恢复程序。 ClassNotFoundException的产生原因：Java支持使用Class.forName方法来动态地加载类，任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。 NoClassDefFoundError产生的原因在于：如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError.造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。 写出引起OutOfMemoryError和StackOverflowError的代码示例OutOfMemoryError和StackOverflowError","categories":[{"name":"技术","slug":"技术","permalink":"http://san-y.github.io/categories/技术/"},{"name":"JAVA","slug":"技术/JAVA","permalink":"http://san-y.github.io/categories/技术/JAVA/"}],"tags":[{"name":"learn","slug":"learn","permalink":"http://san-y.github.io/tags/learn/"},{"name":"java","slug":"java","permalink":"http://san-y.github.io/tags/java/"},{"name":"excption","slug":"excption","permalink":"http://san-y.github.io/tags/excption/"}]},{"title":"testFile","slug":"testFile","date":"2018-09-21T09:11:04.000Z","updated":"2018-09-21T09:54:23.976Z","comments":true,"path":"testFile/","link":"","permalink":"http://san-y.github.io/testFile/","excerpt":"","text":"1.引用块 样例 没有提供参数，则只输出普通的 blockquote content [author[source]] [link] [source_link_title] 引用书上的句子 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 引用 Twitter NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用网络上的文章 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块 在文章中插入代码。 别名： :code [title] [] [url] [link text]1code snippet 样例 普通的代码块 1alert(&apos;Hello World!&apos;); 指定语言 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 12345class test &#123; public static void main(String:args) &#123; System.out.println(\"abc\"); &#125; &#125; 附加说明 Array.map1array.map(callback[, thisArg]) 附加说明和网址 _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 反引号代码块 另一种形式的代码块，不同的是它使用三个反引号来包裹。 class test { public static void main(String:args) { System.out.println(&quot;abc&quot;); } } Youtube在文章中插入 Youtube 视频。 Image 在文章中插入指定大小的图片。","categories":[{"name":"life","slug":"life","permalink":"http://san-y.github.io/categories/life/"},{"name":"test","slug":"life/test","permalink":"http://san-y.github.io/categories/life/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://san-y.github.io/tags/test/"},{"name":"file","slug":"file","permalink":"http://san-y.github.io/tags/file/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-19T08:44:05.037Z","updated":"2018-09-19T08:44:05.038Z","comments":true,"path":"hello-world/","link":"","permalink":"http://san-y.github.io/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}